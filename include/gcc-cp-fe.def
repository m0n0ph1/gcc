/* Interface between GCC C++ FE and GDB  -*- c -*-

   Copyright (C) 2014-2015 Free Software Foundation, Inc.

   This file is part of GCC.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */



/* Push namespace NAME as the current binding level, to which
   newly-introduced decls will be bound.  An empty string identifies
   the global namespace, whereas NULL identifies an anonymous
   namespace.  A namespace named NAME is created in the current scope,
   if needed.  */

GCC_METHOD1 (int, push_namespace,
	     const char *)	      /* Argument NAME.  */

// FIXME: inline namespaces, anyone?

/* Pop the namespace last entered with push_namespace, restoring the
   binding level in effect before the matching push_namespace.  */

GCC_METHOD0 (int, pop_namespace)

/* Return the NAMESPACE_DECL, TYPE_DECL or FUNCTION_DECL of the
   current binding level.  */

GCC_METHOD0 (gcc_decl, get_current_binding_level)

/* Create a new "decl" in GCC, and bind it in the current binding
   level.  A decl is a declaration, basically a kind of symbol.

   NAME is the name of the new symbol.  SYM_KIND is the kind of
   symbol being requested.  SYM_TYPE is the new symbol's C++ type;
   except for labels, where this is not meaningful and should be
   zero.  If SUBSTITUTION_NAME is not NULL, then a reference to this
   decl in the source will later be substituted with a dereference
   of a variable of the given name.  Otherwise, for symbols having
   an address (e.g., functions), ADDRESS is the address.  FILENAME
   and LINE_NUMBER refer to the symbol's source location.  If this
   is not known, FILENAME can be NULL and LINE_NUMBER can be 0.
   This function returns the new decl.

   Use this function to register typedefs, functions and variables to
   namespace and local binding levels, and typedefs, member functions
   (static or not), and static data members to class binding levels.
   Note that, since access controls are disabled, we have no means to
   express private, protected and public.

   FIXME: we would benefit from a gcc_decl argument, to be able to
   introduce friend declarations (what for?  we disable access
   control), using declarations, using directives and namespace
   aliases.

   FIXME: How about override and final virtual functions; =delete and
   =default ctor, dtor and copy-assignment declarations; explicit
   ctors and conversion operators; thread_local variables; other
   attributes?  Do we need an extra flags parameter, or just
   additional gcc_cp_symbol_kinds?  */

GCC_METHOD7 (gcc_decl, new_decl,
	     const char *,	      /* Argument NAME.  */
	     enum gcc_cp_symbol_kind, /* Argument SYM_KIND.  */
	     gcc_type,		      /* Argument SYM_TYPE.  */
	     const char *,	      /* Argument SUBSTITUTION_NAME.  */
	     gcc_address,	      /* Argument ADDRESS.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Return the type of a pointer to a given base type.  */

GCC_METHOD1 (gcc_type, build_pointer_type,
	     gcc_type)			/* Argument BASE_TYPE.  */

// FIXME: we need reference types and pointer-to-member types.

/* Create a new 'class' (or 'struct') type, record it in the current
   binding level, and enter its own binding level.  Initially it has
   no fields.

   NAME is the class name.  BASE_CLASSES indicate the base classes of
   class NAME.  FILENAME and LINE_NUMBER specify the source location
   associated with the class.  */

GCC_METHOD4 (gcc_type, start_new_class_type,
	     const char *,	      /* Argument NAME.  */
	     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

// FIXME: do we need a flag to distinguish structs and classes?  This
// would be beneficial at least for error messages.

/* Create a new 'union' type, record it in the current binding level,
   and enter its own binding level.  Initially it has no fields.

   NAME is the union name.  FILENAME and LINE_NUMBER specify its
   source location.  */

GCC_METHOD3 (gcc_type, start_new_union_type,
	     const char *,	      /* Argument NAME.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Add a non-static data member to a struct or union type.  FIELD_NAME
   is the field's name.  FIELD_TYPE is the type of the field.  BITSIZE
   and BITPOS indicate where in the struct the field occurs.

   FIXME: how about mutable data members?  */

GCC_METHOD5 (int /* bool */, new_field,
	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
	     const char *,		   /* Argument FIELD_NAME.  */
	     gcc_type,			   /* Argument FIELD_TYPE.  */
	     unsigned long,		   /* Argument BITSIZE.  */
	     unsigned long)		   /* Argument BITPOS.  */

/* After all the fields have been added to a struct, class or union,
   the struct or union type must be "finished".  This does some final
   cleanups in GCC, and pops to the binding level that was in effect
   before the matching build_class_type or build_union_type.  */

GCC_METHOD2 (int /* bool */, finish_record_or_union,
	     gcc_type,			   /* Argument RECORD_OR_UNION_TYPE. */
	     unsigned long)		   /* Argument SIZE_IN_BYTES.  */

/* Create a new 'enum' type, and record it in the current binding
   level.  The new type initially has no associated constants.

   NAME is the enum name.  FILENAME and LINE_NUMBER specify its source
   location.  */

GCC_METHOD5 (gcc_type, start_new_enum_type,
	     const char *,	      /* Argument NAME.  */
	     gcc_type,		      /* Argument UNDERLYING_INT_TYPE. */
	     int /* bool */,	      /* Argument SCOPED_ENUM_P.  */
	     const char *,	      /* Argument FILENAME.  */
	     unsigned int)	      /* Argument LINE_NUMBER.  */

/* Add a new constant to an enum type.  NAME is the constant's
   name and VALUE is its value.  */

GCC_METHOD3 (int /* bool */, build_add_enum_constant,
	     gcc_type,		       /* Argument ENUM_TYPE.  */
	     const char *,	       /* Argument NAME.  */
	     unsigned long)	       /* Argument VALUE.  */

/* After all the constants have been added to an enum, the type must
   be "finished".  This does some final cleanups in GCC.  */

GCC_METHOD1 (int /* bool */, finish_enum_type,
	     gcc_type)		       /* Argument ENUM_TYPE.  */

/* Create a new function type.  RETURN_TYPE is the type returned by
   the function, and ARGUMENT_TYPES is a vector, of length NARGS, of
   the argument types.  IS_VARARGS is true if the function is
   varargs.  */

GCC_METHOD3 (gcc_type, build_function_type,
	     gcc_type,			   /* Argument RETURN_TYPE.  */
	     const struct gcc_type_array *,/* Argument ARGUMENT_TYPES.  */
	     int /* bool */)		   /* Argument IS_VARARGS.  */

/* Create a new non-static member function type.  FUNC_TYPE is the
   method prototype, without the implicit THIS pointer, added as a
   pointer to the QUALS-qualified CLASS_TYPE.  */

GCC_METHOD4 (gcc_type, build_method_type,
	     gcc_type,			   /* Argument CLASS_TYPE.  */
	     gcc_type, 			   /* Argument FUNC_TYPE.  */
	     enum gcc_cp_qualifiers,	   /* Argument QUALS.  */
	     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */

// FIXME: add a type-variant builder to add exception type specifiers.

/* Return an integer type with the given properties.  */

GCC_METHOD2 (gcc_type, int_type,
	     int /* bool */,		   /* Argument IS_UNSIGNED.  */
	     unsigned long)                /* Argument SIZE_IN_BYTES.  */

/* Return a floating point type with the given properties.  */

GCC_METHOD1 (gcc_type, float_type,
	     unsigned long)			/* Argument SIZE_IN_BYTES.  */

/* Return the 'void' type.  */

GCC_METHOD0 (gcc_type, void_type)

/* Return the 'bool' type.  */

GCC_METHOD0 (gcc_type, bool_type)

/* Create a new array type.  If NUM_ELEMENTS is -1, then the array
   is assumed to have an unknown length.  */

GCC_METHOD2 (gcc_type, build_array_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     int)			  /* Argument NUM_ELEMENTS.  */

/* Create a new variably-sized array type.  UPPER_BOUND_NAME is the
   name of a local variable that holds the upper bound of the array;
   it is one less than the array size.  */

GCC_METHOD2 (gcc_type, build_vla_array_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     const char *)		  /* Argument UPPER_BOUND_NAME.  */

/* Return a qualified variant of a given base type.  QUALIFIERS says
   which qualifiers to use; it is composed of or'd together
   constants from 'enum gcc_cp_qualifiers'.  */

GCC_METHOD2 (gcc_type, build_qualified_type,
	     gcc_type,			      /* Argument UNQUALIFIED_TYPE.  */
	     enum gcc_cp_qualifiers)	      /* Argument QUALIFIERS.  */

/* Build a complex type given its element type.  */

GCC_METHOD1 (gcc_type, build_complex_type,
	     gcc_type)			  /* Argument ELEMENT_TYPE.  */

/* Build a vector type given its element type and number of
   elements.  */

GCC_METHOD2 (gcc_type, build_vector_type,
	     gcc_type,			  /* Argument ELEMENT_TYPE.  */
	     int)			  /* Argument NUM_ELEMENTS.  */

/* Build a constant.  NAME is the constant's name and VALUE is its
   value.  FILENAME and LINE_NUMBER refer to the type's source
   location.  If this is not known, FILENAME can be NULL and
   LINE_NUMBER can be 0.  */

GCC_METHOD5 (int /* bool */, build_constant,
	     gcc_type,		  /* Argument TYPE.  */
	     const char *,	  /* Argument NAME.  */
	     unsigned long,	  /* Argument VALUE.  */
	     const char *,	  /* Argument FILENAME.  */
	     unsigned int)	  /* Argument LINE_NUMBER.  */

/* Emit an error and return an error type object.  */

GCC_METHOD1 (gcc_type, error,
	     const char *)		 /* Argument MESSAGE.  */
